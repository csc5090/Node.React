2025 11 14

Node 설치 => NVM => 멀티 버전 설치 => Node 설치하면 JS를 OS 위에서 실행 가능 => JRE가 비유될 수 있음.
          => JS : 인터프리터 방식

NPM => Node Package Manager => Maven 빌더에 비유될 수 있음.
        필요한 모듈 설치/삭제를 편하게 해줌. Node를 설치하면 자동으로 같이 설치됨.
        Package.json에 설치한 모듈이 dependency로 등록됨.
        Package-lock.json 파일은 설치한 모듈의 개별 버전정보를 가짐 (Package.json은 도커 같은 느낌.)
        Package.json 파일의 script에 명령어 등록 가능(start/test만 run 생략 가능. start/npm run start)
        
        모듈 검색은 npmjs에서 => 자바의 maven과 비슷한 역할.
        배포시 node_modules 폴더는 주지 않음(용량만 큼)

webserver 만듬 => express 이용 => Spring으로 하기 때문에 그리 중요하지 않다.

의존성 : 한 모듈/코드 조각이 작동하기 위해 다른 모듈/코드 조각(라이브러리, 함수, 클래스 등)을 필요로 하는 관계가 의존성.

누가 필요한가? (의존하는 주체, Client)
무엇이 필요한가? (의존성의 대상, Service)

모듈 : 위 관계를 정의하고 관리하는 구조
모듈의 import/require 메커니즘을 통해 자신이 필요한 다른 모듈이 무엇인지 분명하게 밝히고, 이 관계를 체계적으로 다룬다.


원시 타입 : string number boolean => 복사
객체타입 원시타입 아닌 거 전부 (function도 객체) = 참조(별명)

var(생명의 경계선 function키워드) vs let/const ( {}기로가 생명의 경계선 )

const 주의 사항 : 객체 타입인 경우 속성과 메서드, 즉 내용물은 바꿀 수 있음.

Wrapper(랩퍼) : 불편한 원시타입을 편하게 쓰게 해줌

string => String, number=> Number, boolean => Boolean

자동형변환.

JSON => 배열식 접근법

함수 => 끝에 return이 생략되어 있음. return은 함수의 종료를 알린다.
        if else 에서 else는 생략 가능. 함수 호출된 자리에는 return값이 남음.

콜백함수 => 함수의 매개변수로 넘어가는 함수. 당연히 뒤에 불릴 수 밖에 없어 콜백이라고 함.
           함수의 선언과 호출을 헷갈리면 안됨.

전역변수 선언은 window의 메소드 선언과 같고, 전역변수 선언(var)은 window의 속성 선언과 같음.
메소드 안의 this는 해당 메소드를 가진 객체를 가리킴.
참조를 이용해서 부르는 형태를 바꾸면 this가 가리키는 값이 바뀌어버림.

call / apply 사용법이 매개변수 넘기는 법 만 다름. apply로 무조건 배열
bind  사용법이 call 하고 똑같은데, 내부적으로 새함수를 return해줌

