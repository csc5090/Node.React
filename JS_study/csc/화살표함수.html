<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <script>
        // 화살표 함수(Arrow Function)
        // 자바나 c를 하던 사람들은 이걸 람다라고도 부른다.
        // 일종의 축약 기법인데, function 키워드가 엄청나게 사용되니 조금이라도 줄이기 위해 탄생했다.

        function jiwon(name) {
            return "안녕하세요" + name;
        }

        /* const jiwon2 = () => {
            return "안녕하세요2" + name;
        }; */

        //위와 같다.
        const jiwon2 = name => "안녕하세요2" + name
        
        console.log("체크1: ", jiwon);
        console.log("체크2: ", jiwon2);

        // ==============================================================================
// 화살표 함수 (Arrow Function) 개요
// ==============================================================================
// 1. **표현식**: (parameters) => { expression } 형태로 사용되는 간결한 함수 표현식.
// 2. **설계 목적**: 콜백 함수 등 간단한 함수를 작성할 때 구문을 단순화하고, 렉시컬 this를 제공하기 위함.
// 3. **경량화**: 일반 function 키워드 함수가 가지는 일부 바인딩(this, arguments 등)을
//               제공하지 않아 더 가볍게 작동함.

// ==============================================================================
// 주요 특징 (일반 함수와의 차이점)
// ==============================================================================
// 1. **렉시컬 this (Lexical this)**:
//    // - **가장 큰 특징**. 화살표 함수는 자신만의 this 바인딩을 생성하지 않음.
//    // - 함수가 **정의된(선언된) 시점**의 **외부 스코프(Lexical Scope)**의 this를 상속받아 사용함.
//    // - 따라서, .call(), .apply(), .bind() 메서드를 사용해도 this 값을 변경할 수 없음.
// 2. **arguments 객체 미지원**:
//    // - 함수 내부에서 arguments 객체에 접근할 수 없음.
//    // - 대신, **나머지 매개변수 (Rest Parameters, ...args)** 문법을 사용해야 함.
// 3. **생성자(Constructor) 사용 불가**:
//    // - new 키워드와 함께 호출될 수 없음 (this 바인딩이 없기 때문).
//    // - prototype 속성이 존재하지 않음.
// 4. **Generator (yield) 미지원**:
//    // - 제너레이터 함수로 사용될 수 없음.

// ==============================================================================
// 화살표 함수를 사용해야 할 때 (적절한 사용처)
// ==============================================================================
// 1. **콜백 함수 (Callbacks)**:
//    // - 배열 메서드 (map, filter, reduce 등), setTimeout, Promise 체인 등에서
//    //   간결한 구문으로 함수를 전달할 때 유용함.
// 2. **this 바인딩을 유지해야 할 때 (렉시컬 this 활용)**:
//    // - 객체의 메서드 내부에서 비동기 작업(setTimeout, 이벤트 리스너 등)의 콜백을 작성할 때,
//    //   외부(메서드)의 this(즉, 객체 자체)를 그대로 사용해야 할 경우 유용함.
//    //   (일반 함수에서 this를 유지하려면 bind() 또는 self = this 패턴이 필요했음)
// 3. **단순한 표현식 반환**:
//    // - 함수 본문이 return 문 하나만 있을 경우, 중괄호({})와 return 키워드를 생략할 수 있어
//    //   가독성이 매우 높아짐.
//    //   (예: const add = (a, b) => a + b;)

// ==============================================================================
// 화살표 함수를 피해야 할 때 (일반 함수를 사용해야 할 때)
// ==============================================================================
// 1. **객체의 메서드 (Method)**:
//    // - 객체 리터럴 내에서 메서드를 정의할 때 (this가 객체 자체가 아닌 전역 객체나 외부 스코프를 가리키게 됨).
//    // - **this가 호출 시점에 따라 동적으로 바인딩**되어야 할 경우 (일반 함수 필수).
// 2. **생성자 함수 (Constructor)**:
//    // - new 키워드로 새로운 인스턴스를 생성해야 할 때.
// 3. **이벤트 핸들러**:
//    // - DOM 이벤트 리스너에서 **this가 이벤트 대상 요소**를 가리켜야 할 때.
// 4. **arguments 객체에 반드시 접근해야 할 때**.
// 5. **Generator 함수를 정의해야 할 때**.
// ==============================================================================
    


    </script>
</head>
<body>
    
</body>
</html>